처음엔 Heap sort로 풀면 될 줄 알았다. (문제의 테스트 케이스가 우연찮게 맞아 떨어졌다.) <br>
하지만 다른 테스트 케이스로 생각해보니까 전혀 적용되지 않았다….

<hr>

여러 정렬을 찾아보던 중 Radix sort를 이용하면 해결이 가능했다. (이후에 해결이 안됨을 깨달았다.)

- **Radix Sort (기수 정렬)**
  - 낮은 자리 수부터 비교하여 정렬하는 알고리즘
  - 비교 연산을 하지 않으며 정렬 속도가 빠르지만 데이터 전체 크기에 기수 테이블의 크기만한 메모리가 필요하다. (공간 복잡도 증가)

    <p align='center'><img src="https://github.com/eeeeeddy/Coding_Test_Practice/assets/71869717/a426be99-3275-45f9-820e-e93ff4122447"></p>

    하지만 Radix Sort로의 접근은 좋았으나, 문제를 완벽하게 해결하여 주진 않았다.

<hr>

Radix Sort를 이용하는 과정에서 역시 테스트 케이스는 해결이 됬으나 반례가 있었다. <br>
`numbers = [3, 30, 934, 5, 9]` 일 경우에 정답은 **99345330**이다. <br>
그러나 단순히 Radix Sort를 이용할 경우에는 **93430953**이 나오기 때문에 문제가 있다고 생각했다. <br>
조금 고민해보니 **자릿수가 다른게** 문제였다. (자릿수가 다르기 때문에 '9'가 중간에 배치되는 것이었다.) <br>
그럼 자릿수를 맞춰주어야하는데 어떻게 맞추어 주느냐가 문제였다. <br>
처음엔 단순히 자릿수를 맞춰주기 위해 numbers를 모두 문자열을 바꾸고 문자열 ‘*'을 채워주었다. <br>
(비슷하게 마지막 숫자를 채워주는 아이디어도 있었다.) <br>
하지만 채워주는 건 나중에 정답을 구하기 위해 채워준 만큼 빼야하는데 그걸 구하는 게 만만치 않았다.

- **문자열의 대소비교 (Python)**
  - 파이썬은 string 타입인 숫자도 대소 비교가 가능하다. 다만 일반적인 숫자의 대소 비교와는 차이점이 있다.

    >print("999" < "9808") <br>
    >위의 수식은 당연히 True 가 나와야하지만 코드를 실행해보면 False 가 출력된다. <br>
    >문자열 비교 시 앞자리부터 대소 비교를 하기 때문이다. <br>
    >① 999의 9와 9808의 9 비교 → 같기 때문에 다음 자리 비교 <br>
    >② 999의 9와 9808의 8 비교 → 9가 더 크기 때문에 파이썬은 999가 더 크다고 인식 <br>

<hr>

자릿수를 맞추기 위한 정답은 문자열 반복이었다. “30”일 경우 “303030”으로 반복해서 대소 비교를 하면 가능했다. <br>
numbers의 각 원소들의 자릿수를 맞추기보다는 적어도 3자리 이상은 만들어주어야 했다. <br>
(numbers의 원소는 0 이상 1,000이하이므로) <br>
한자리 숫자일 경우를 생각해서 문자열을 3번 반복해서 내림차순으로 정렬한 후에 원소별로 3으로 나누어 더해주면 정답이다.
